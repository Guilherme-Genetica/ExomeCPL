# Orientações gerais:
# Veja como baixar os arquivos de referência em ReferenceFiles
# Dados iniciais a analisar (FASTQ) = raw_reads.fq
# Genoma humano de referência (FASTA) = reference.fa
# Banco de dados com variantes (VCF) = dbsnp137.vcf

# 1- Gerando o índice BWA

$ bwa index reference.fa

# 2- Gerando o arquivo índice FASTA

$ samtools faidx reference.fa

# 3- Gerando o dicionário da sequencia = reference.dict - cria um arquivo formatado como um cabeçalho do SAM mas para o genoma de referência.

$ java -jar CreateSequenceDictionary.jar \
    REFERENCE=reference.fa \
    OUTPUT=reference.dict

# O output ou -o é sempre o arquivo de saída. O input ou -I é sempre o de entrada.

# 5- Preparando as informações apropriadas do grupo de leitura (etiquetando o GATK)
# ex.   @RG\tID:group1\tSM:sample1\tPL:illumina\tLB:lib1\tPU:unit1
# Onde as informações do grupo de leitura (read group=@RG) é onde se escreve a meta-data (um conjunto de dados que descreve e fornece informações sobre outros dados) da amostra.
# \t é um caractere de tabulação
# ID é o identificador da corrida (ex. lane donde o dado foi extraído no Illumina)
# SM é o nome associado com o DNA na amostra (p.ex NA12878). Toda a análise no GATK é feita tendo por base a amostra, por isso definir este nome é importante.
# PL é a plataforma que foi usada (lista no manual do GATK, ex. illumina, pacbio, iontorrent...)
# LB Identifica a biblioteca de qual DNA foi sequenciado, com isso é possível linkar os dados com os processos do laboratório e fazer a análise de erros e qualidade.
# PU Identifica a unidade da plataforma nesta corrida. (ex flowcell-barcode.lane - único identificador para corridas no Illumina.
# Para maiores informações (http://samtools.sourceforge.net/SAM1.pdf).

# 5- Gerando o arquivo SAM

$ bwa mem -R ’<read group info>’ -p reference.fa raw_reads.fq >aligned_reads.sam

# -R define a linha completa do cabeçalho do grupo de leitura.
# -t define o número de threads (com 4 threads, o mapeamento será executada em 4 processos paralelamente)
# -p supõe que o primeiro arquivo de consulta de entrada (genoma de referência) esteja intercalado com o FASTA / Q "emparelhada" (paired end). No entanto lembre-se que a referencia.fa pode ser não emparelhada (single end)
# Para outras opções veja http://bio-bwa.sourceforge.net/bwa.shtml

6 - Convertendo BAM, ordenando e marcando duplicatas usando comando do Picard. Observe que sempre o arquivo Output é o que foi gerado, neste caso nomeamos de dedup devido à dedução de duplicatas geradas no processo de leitura do DNA.

$ java -jar MarkDuplicates.jar \
    INPUT=aligned_reads.sam \
    OUTPUT=dedup_reads.bam \
    SO=coordinate

7 - Fazendo novo alinhamento baseado nos indels importante para alinhar os indels que podem ter sido mapeados com erros. Criando a lista de alvos, intervalos para o alinhamento, usando o GATK.

$ java -jar GenomeAnalysisTK.jar \
    -T RealignerTargetCreator \
    -R reference.fa \
    -I dedup_reads.bam \
    -L 20 \
    -known gold_indels.vcf \
    -o target_intervals.list

# Observe que o output -o cria o um arquivo que é a lista dos intervalos que o programa identifica como necessários para o alinhamento, neste caso o alvo (-L) foi o cromossomo 20. 
# A lista dos sítios de indels conhecidos (gold_indels) são usados como alvos para o alinhamento. Apenas use-a se houver para o seu organismo.

# 8 - Rodando o GATK para realinhar:

$ java -jar GenomeAnalysisTK.jar \
    -T IndelRealigner \
    -R reference.fa \
    -I dedup_reads.bam \
    -targetIntervals target_intervals.list \
    -known gold_indels.vcf \
    -o realigned_reads.bam

# O arquivo de saída é o realigned_reads.bam que contem todos os reads originais mas melhor alinhados. Observe que não foi necessário colocar o -L 20 pois já tinha sido definido quando foi criado o target_intervals.list.

# 9- Analisando os padrões de covariação do conjunto de dados sequenciados. A estimativa de erro por base sequnciada é a base para pontuação de qualidade, no entanto, esta estimativa é frequentemente envesada. Desta forma a recalibração serve para produzir um BAM adequado para análise.

$ java -jar GenomeAnalysisTK.jar \
    -T BaseRecalibrator \
    -R reference.fa \
    -I realigned_reads.bam \
    -L 20 \
    -knownSites dbsnp.vcf 
    -knownSites gold_indels.vcf \
    -o recal_data.grp \
    -plots before_recal.pdf

# Este processo cria o GATKReport (relatório) chamado recal_data.grp, que contem tabelas com os dados de covariação que serão usadas para recalibrar a qualidade das bases sequenciadas. Também é gerado um .pdf que mostra a diferença das qualidades calculadas previamente. É necessário prover ao programa a configuração dos conjuntos dos sítios conhecidos (knownSites) neste caso foi usado o .vcf do dbsnp e do gold_indels.

# 10 - Demonstrando a qualidade das bases após a recalibração. Observe o .pdf plotado. A opção - BQSR permite prever a recalibração baseado na tabela gerada antes.

$ java -jar GenomeAnalysisTK.jar \
    -T BaseRecalibrator \
    -R reference.fa \
    -I realigned_reads.bam \
    -L 20 \
    -BQSR recal_data.grp \
    -o post_recal_data.grp \
    -plots after_recal.pdf

# 11 - Aplicando a recalibração aos dados da sequencia via GATK. O Arquivo recal_reads.bam é gerado com as pontuações de qualidade acuradas para substituição de bases, inserções e deleções. A opção emit_original_quals ao comando PrintReads permite reter a qualidade anterior marcada com OQ no .bam gerado.


$ java -jar GenomeAnalysisTK.jar \
    -T PrintReads \
    -R reference.fa \
    -I realigned_reads.bam \
    -L 20 \
    -BQSR recal_data.grp \
    -o recal_reads.bam
    
# 12 - Compressão dos dados com ReduceReads (etapa opcional), é usado para permitir apenas o necessário para chamada de SNP e indels, funciona bem para BAMs com coberturas médias > 20x, mas nunca para <10. Este arquivo pode não ser bem lido em outras ferramentas não GATK.

$ java -jar GenomeAnalysisTK.jar \
    -T ReduceReads \
    -R reference.fa \
    -I recal_reads.bam \
    -L 20 \
    -o reduced_reads.bam
    

13- Chamada de variantes:

$ java -jar GenomeAnalysisTK.jar \
    -T HaplotypeCaller \
    -R reference.fa \
    -I reduced_reads.bam \
    -L 20 \
    --genotyping_mode DISCOVERY \
    --output_mode EMIT_VARIANTS_ONLY \
    --stand_emit_conf 10 \
    --stand_call_conf 30 \
    -o raw_variants.vcf
    
# Parâmetros básicos para chamada de variantes.
# Onde: --genotyping_mode, determina o modo genotipado. Especifica como queremos que  programa determine os alelos alternativos  a serem usados na geotipagem. Por padrão, o modo DISCOVERY escolherá os alelos mais prováveis dentre os que vê nos dados. No modo GENOTYPE_GIVN_ALLELES, o programa somente usará os alelos de dentro de um arquivo .VCF (usando o argumento -alleles), que só é útil para determinar se uma amostra tem um genótipo espeífico de interesse.
# Onde: --output_mode, determina o modo de saída. No modo EMIT_VARIANTS_ONLY padrão, o programa emitirá chamadas apenas para sítios que parecem ser variantes (se com alta ou baixa confiança). No modo EMIT_ALL_CONFIDENT_SITES, o programa emitirá chamadas em sitios nos quais tenha alta confiança se o sitio é variante ou não (ex. se possui a referência do alelo). No modo EMIT_ALL_SITES, o programa emitirá chamadas em qualquer sitio solicitável (por exemplo, sitios em que haja dados utilizáveis) independentemente da confiança. Esse último argumento é destinado apenas a mutações pontuais (SNPs) no modo de genotipagem DISCOVERY ou geralmente quando executado no modo de genotipagem GENOTYPE_GIVEN_ALLELES. Não há garantia de que ele possa produzir um conjunto abrangente de indels no modo DISCOVERY.
# Onde: --stand_emi_conf, determina o limiar de confiança das emissões. Esse é o limite mínimo de confiança (com escala em phred) no qual o programa deve emitir sites que parecem ser possivelmente variantes.
# Onde: --stand_call_conf, determina o limiar de confiança das chamadas. Também em Phred, em que o programa emite sitios variantes conforme chamado. Se o genótipo associado de um sitio tiver uma pontuação de confiança menor que o limiar da chamada, o programa emitirá o site como filtrado e o anotará como LowQual. Esse limite separa as chamadas de alta confiança das chamadas de baixa confiança.

# Aqui terminamos o protocolo 1 e 2. No arquivo VariantSeq daremos continuação ao processo.
